<!DOCTYPE html>
<!-- ●ここから人間用のヘッダー● -->
<html lang="ja">

<head>
 <link rel="manifest" href="/manifest.json">

 <script>
  if ('serviceWorker' in navigator) {
   navigator.serviceWorker.register('/service-worker.js')
    .then(registration => {
     console.log('ServiceWorker registration successful with scope: ', registration.scope);
    })
    .catch(error => {
     console.log('ServiceWorker registration failed: ', error);
    });
  }
 </script>

 <!-- Google tag (gtag.js) -->
 <script async src="https://www.googletagmanager.com/gtag/js?id=G-827JM6N5CS"></script>
 <script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-827JM6N5CS');
 </script>

 <!-- Microsoft tag -->
 <script>
  (function (c, l, a, r, i, t, y) {
   c[a] = c[a] || function () { (c[a].q = c[a].q || []).push(arguments) };
   t = l.createElement(r); t.async = 1; t.src = "https://www.clarity.ms/tag/" + i;
   y = l.getElementsByTagName(r)[0]; y.parentNode.insertBefore(t, y);
  })(window, document, "clarity", "script", "obazqypsh8");
 </script>

 <meta charset="UTF-8">


 <!--基本のメタタグ-->
 <meta name="description" content="ここではGoogle App Engineで用いるyamlについて詳しく書いています。">
 <meta name="keywords" content="個人サイト, Google App Engine, yaml">
 <meta name="robots" content="index, follow">
 <meta property="og:title" content="App Engineのapp.yamlでWebサイトを設定する">
 <meta property="og:description" content="ここではGoogle App Engineで用いるyamlについて詳しく書いています。">
 <meta property="og:image" content="../image/アナザーエデンのバディ_ピスケ.png">
 <meta property="og:url" content="https://feinatelier.org/contents/appyaml.html">

 <!--検索ヒット時のアイコン-->
 <script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "App Engineのapp.yamlでWebサイトを設定する",
  "url": "https://feinatelier.org/contents/appyaml.html",
  "logo": "https://feinatelier.org/image/barracuda.jpeg"
}
</script>

 <!--レスポンシブデザイン-->
 <meta name="viewport" content="width=device-width, initial-scale=1.0">

 <!--CSS-->
 <link rel="stylesheet" type="text/css" href="/css/style.css">
 <link rel="stylesheet" type="text/css" href="/css/header.css">
 <link rel="stylesheet" type="text/css" href="/css/footer.css">
 <link rel="stylesheet" type="text/css" href="../css/menu.css">
 <link rel="stylesheet" type="text/css" href="../css/feinpan.css">
 <link rel="stylesheet" type="text/css" href="../css/feinheadline1.css">
 <link rel="stylesheet" type="text/css" href="../css/flower.css">
 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-tomorrow.min.css">


 <!--JavaScript-->
 <script src="../script/underline.js"></script>
 <script src="../script/feinfade.js"></script>
 <script src="../script/feinScroll.js"></script>


 <!-- prismの読み込み -->
 <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-bash.min.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-python.min.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/components/prism-yaml.min.js"></script>

 <!-- google fonts -->
 <link rel="preconnect" href="https://fonts.googleapis.com">
 <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
 <link
  href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@100..900&family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap"
  rel="stylesheet">

 <!--ページタイトル-->
 <title>App Engineのapp.yamlでWebサイトを設定する</title>

 <!--ASノーナのファビコン-->
 <link rel="icon" sizes="32x32" href="../favicon.ico" type="image/x-icon">
 <link rel="apple-touch-icon" sizes="180x180" href="/icons/appleicon.png">
</head>

<body>

 <nav class="den_nav">
  <ul>
   <li>
    <a href="/" class="animated-link feinhome-link">
     <img src="/menu/mspass.webp" alt="このサイトのシンボルマーク" class="feinhome">
     <span>fein's home</span>
    </a>
   </li>

   <li><a href="/another-eden/anaden_sitemap.html" class="animated-link">Another Eden</a></li>
   <li><a href="/fish/fish_sitemap.html" class="animated-link">Outdoor Activities</a></li>
   <li><a href="/contents/site_create.html" class="animated-link">Personal Website Creation</a></li>
   <li><a href="/contents/protect.html" class="animated-link">AI Block</a></li>
   <li><a href="/contents/rss.html" class="animated-link">Updates</a></li>
  </ul>
 </nav>

 <!--レスポンシブデザイン-->
 <div class="feincontainer">

  <!--パンくずリスト-->
  <div>
   <ol class="breadcrumb">
    <li class="breadcrumb-item"><a href="/">Home（グラスタの場所一覧表〜入手範囲別〜）</a></li>
    <li class="breadcrumb-item"><a href="site_create.html">個人サイト制作：サイトマップ</a></li>
    <li class="breadcrumb-item active" aria-current="page">App Engineのapp.yamlでWebサイトを設定する</li>
   </ol>
  </div>



  <!-- ハンバーガーメニュー -->
  <div class="fden-hamburger-menu">
   <button class="fden-hamburger-button" id="fden-hamburger-button" onclick="toggleMenu()">☰ メニューを開く ▼</button>
   <div class="fden-menu" id="fden-menu">
    <!-- メニュー内容は外部ファイルから読み込む -->
    <div id="fden-menu-content"></div>
   </div>
  </div>
  <script src="../script/menu.js"></script>
  <!-- ハンバーガーメニューここまで -->

  <!--サイトタイトル-->
  <div class="header-frame">
   <div class="header-container">
    <img src="../image/cloudsitetitle.jpg" alt="Fein Atelier - org" class="header-image">
    <div class="header-text">
     <a href="https://feinatelier.org/">Fein Atelier - org</a>
    </div>
   </div>
  </div>

  <div class="spacer"></div>
  <button id="generate-headings" data-open-text="App Engineのapp.yamlでWebサイトを設定するの目次を開く ▼"
   data-close-text="App Engineのapp.yamlでWebサイトを設定するの目次を閉じる ▲">App Engineのapp.yamlでWebサイトを設定するの目次を開く
   ▼</button><!--目次の自動生成-->

  <div class="spacer"></div>
  <p><a href="site_create.html">個人サイト制作：サイトマップへ戻る</a></p>

  <!-- ●人間用のヘッダーここまで。直下でコンテンツ開始● -->

  <h1 class="background-waveimage-heading"><span>App Engineのapp.yamlでWebサイトを設定する</span></h1>

  <p>Google App Engineのapp.yamlファイルは、アプリケーションの設定情報を記述するためのファイルです。<br>
   yaml（ヤムル）形式のファイルであり、人間が読みやすい形式で記述されます。<br>
   App Engineは、このファイルを参照して、アプリケーションをどのようにデプロイし、どの環境で実行するかを決定します。</p>

  <p>たとえば、app.yamlファイルにはアプリケーションのランタイム（つまり、使用するプログラミング言語やバージョン）を指定する項目があります。<br>
   また、アプリケーションが依存する外部ライブラリやモジュールを記述することもできます。<br>
   さらに、URLマッピングの設定も行うことができ、どのURLパスに対してどのハンドラー（処理プログラム）を割り当てるかを指定できます。</p>


  <p>また、app.yamlファイルにはスケーリングの設定も含まれており、アプリケーションのトラフィックに応じてインスタンスを自動的に増減させる方法を指定できます。<br>
   これが重要なんですよ。<br>
   要するに自分でサーバのスペックみたいなものを自由に調整できるのです。<br>
   この仕組みがあることで、アプリケーションが高負荷のときにもスムーズに動作するように調整が行われることになります。</p>

  <p>このように、app.yamlファイルは、Google App Engine上でアプリケーションを実行するための重要な設定情報を提供するファイルであり、アプリケーションの動作環境や動作方法を細かく制御する役割を持っているのです。
  </p>


  <h2>app.yaml構文の詳説</h2>
  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(296).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p>app.yamlの構文では、URLやファイルパスのパターンを記述する際に、POSIX拡張正規表現を使用するので、使いやすい文字列パターンの指定が可能です。<br>
    また、グループ化したパターンを後で参照する機能や、Perl拡張の特殊文字（例:\wや\d）もサポートされています。<br>
    要するに、より柔軟で詳細なパターンマッチングができるということです。</p>

   <p>ここで、yamlの事例を見てみましょう。</p>
  </div>


  <div class="code-container">
   <pre><code class="feintyping language-yaml">
runtime: python312
instance_class: F2
env_variables:
BUCKET_NAME: "example-gcs-bucket"
handlers:
# Matches requests to /images/... to files in static/images/...
- url: /images
static_dir: static/images
- url: /.*
secure: always
redirect_http_response_code: 301
script: auto

</code></pre>
  </div>

  <p><a href="https://cloud.google.com/appengine/docs/standard/reference/app-yaml?hl=ja&tab=python">App Engine
    app.yaml リファレンス</a>も参考にして頂けるとよろしいかと。<br>
   このyaml構文を詳しく説明すると、次のようになります。</p>

  <div class="code-container">
   <pre><code class="feintyping language-yaml">
# アプリケーションのランタイム環境を指定します。この場合は Python 3.12 を使用します。
runtime: python312

# インスタンスのクラスを指定します。F2 は、適度なパフォーマンスとリソースを提供するクラスです。
instance_class: F2

# 環境変数を指定します。アプリケーション内で使用する設定値を管理します。
env_variables:
# Google Cloud Storage バケットの名前を指定します。
BUCKET_NAME: "example-gcs-bucket"

# リクエストを処理するためのハンドラーを定義します。
handlers:
# /images で始まるURLパスに対して、静的ディレクトリ static/images 内のファイルをマッピングします。
# 例えば、/images/logo.png は static/images/logo.png にマッピングされます。
- url: /images
static_dir: static/images

# すべてのリクエストに一致させます。/.* はすべての URL パスにマッチする正規表現です。
- url: /.*
# HTTP を HTTPS にリダイレクトします。secure: always は常に HTTPS を使用することを示します。
secure: always
# HTTP リダイレクトのレスポンスコードを 301（永久的なリダイレクト）に設定します。
redirect_http_response_code: 301
# スクリプト自動設定を使用します。script: auto は自動的に適切なスクリプトを選択することを示します。
script: auto

</code></pre>
  </div>

  <p>yaml構文を全て学ぼうとするとキリがないでしょう。<br>
   しかしApp Engineを使う場合、Googleの公式ドキュメントに記載されている範囲内の情報くらいは把握しておくとラクです。</p>

  <h3>ランタイムとアプリの要素</h3>

  <h5>app_engine_apis</h5>
  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(297).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p><span class="small-orange-text">※必ずしも設定する必要はありません。</span></p>
   <p>これはApp Engineの最新の環境で昔からあるサービスを使いたい場合、この設定を「true」にする、という意味です。<br>
    App Engineの中に、「App Engine APIs」という、アプリが利用するためのさまざまな機能やサービスを含むAPIがあります。<br>
    2025年1月現在、App Engineの最新のランタイム環境は第2世代ランタイムです。─ ランタイム：アプリケーションが実行される環境のこと ─
    一方、以前からある複数の機能やサービスをまとめて提供する従来のバンドルサービスは、第1世代から存在しています。<br>
    このフィールドを「true」に設定することで、従来のバンドルサービスを第2世代ランタイムで使えるということです。</p>

   <p>App Engineの従来のバンドルサービスには、次のような機能やツールが含まれています。</p>
  </div>

  <dl>
   <dt>Memcache</dt>
   <dd>高速のキャッシュサービス。アプリのパフォーマンス向上に役立ちます。</dd>

   <dt>Mail</dt>
   <dd>アプリケーションからメールを送信するためのサービス。</dd>

   <dt>XMPP</dt>
   <dd>メッセージング用プロトコルを使って、リアルタイム通信を可能にするサービス。</dd>

   <dt>Blobstore</dt>
   <dd>大量のデータ（画像や動画など）を保存するためのサービス。</dd>

   <dt>Users</dt>
   <dd>ユーザー認証を簡単に行うためのサービス。</dd>
  </dl>

  <p>これらのサービスはアプリケーション開発のさまざまなニーズに対応するためのものですね。<br>
   第1世代からずっと使われている定番の機能です。<br>
   第2世代ランタイムでもこれらを使いたい場合には、上記の説明のように、yamlファイルで設定を「true」にする必要があります。</p>

  <h5>build_env_variables</h5>
  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(298).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p><span class="small-orange-text">※必ずしも設定する必要はありません。</span></p>
   <p>この build_env_variables を使って、ビルド時に必要な情報を整理し、アプリケーションを正しく動作させる設定を行います。<br>
    ビルド環境変数とはソフトウェアの構築 ─ しばしば「ビルド」と呼ばれる ─ 中に使用される設定情報です。<br>
    例えばデータベースの接続情報やAPIキーなど、ビルド時に必要な情報をここで指定します。<br>
    buildpacksはプログラムをビルドして実行可能な形式に変換するツールであり、ソースコードを受け取って、それを実行可能なアプリケーションにします。</p>

   <p>つまり、app.yamlファイルの中で build_env_variables を使ってビルド環境変数を定義するというのは、ビルド中に必要な情報を指定しておくということです。<br>
    少し事例を見てみましょう。</p>
  </div>


  <div class="code-container">
   <pre><code class="feintyping language-yaml">
build_env_variables:
DATABASE_URL: "mysql://user:password@localhost:3306/mydatabase"
API_KEY: "your-api-key"

</code></pre>
  </div>

  <p>こうやって書くと、ビルド中に DATABASE_URL や API_KEY といった情報が使用されます。</p>

  <h5>default_expiration</h5>
  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(300).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p><span class="small-orange-text">※必ずしも設定する必要はありません。</span></p>
   <p>アプリケーションにある静的ファイル ─ 画像、CSS、JavaScriptなど ─ のキャッシュ期間を設定し、読み込み速度を改善するための設定です。<br>
    キャッシュ期間とは、ファイルがブラウザやサーバーに保存される期間のことです。<br>
    この期間中に再度そのファイルにアクセスすると、サーバーからではなくキャッシュから読み込まれます。<br>
    するとWebコンテンツの表示が早くなります。</p>

   <p>キャッシュ期間は、次のような単位の文字列を付け、数値と組み合わせて設定します。</p>
  </div>


  <ul>
   <li><strong>d</strong> は日数（days）を表します。</li>
   <li><strong>h</strong> は時間（hours）を表します。</li>
   <li><strong>m</strong> は分（minutes）を表します。</li>
   <li><strong>s</strong> は秒（seconds）を表します。</li>
  </ul>

  <p>例えば「4d 5h」と指定すると、そのファイルのキャッシュ有効期限は最初にリクエストされてから4日と5時間後になります。<br>
   次に、app.yamlファイルへdefault_expirationを設定した例を示します。</p>

  <div class="code-container">
   <pre><code class="feintyping language-yaml">
runtime: python312
default_expiration: "4d 5h"
handlers:
# ...以下略

</code></pre>
  </div>

  <p>この設定により、静的ファイルのキャッシュ有効期限が4日と5時間に設定されます。<br>
   もしdefault_expirationを省略した場合、本番環境ではサーバーが自動的に有効期限を10分に設定します。</p>

  <h5>entrypoint</h5>
  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(299).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p><span class="small-orange-text">※必ずしも設定する必要はありません。</span></p>
   <p>アプリがどうやって起動するかを細かくコントロールできます。<br>
    アプリがHTTPリクエスト（ウェブからのアクセス）を受け取るには、ポート8080でリッスンするウェブサーバーを起動する必要があります。─ ポート8080を使って外部からのアクセスを受け付ける準備をしている状態のことです ─<br>
    entrypointには、そのためのコマンドを設定します。</p>
   <p>当サイトのようにPythonを使っている場合、entrypointを指定しないと、App Engineが自動的にGunicornというウェブサーバーを起動してくれます。─ 詳しく後述します ─<br>
    しかし特別な設定やカスタマイズをしたい場合は、自分でentrypointを指定することができます。<br>
    例えば独自のサーバーを起動するコマンドを指定する場合は、app.yamlファイルに以下のように記述します。</p>
  </div>

  <div class="code-container">
   <pre><code class="feintyping language-yaml">
entrypoint: python my_server.py

</code></pre>
  </div>

  <p>すでに上記で簡単に触れましたが、もしentrypointを明示的に指定しなかった場合でも、Google App
   Engineが内部的にGunicornというウェブサーバーを使用してアプリを起動し、ポート8080でのリクエストを受け付けるようにしてくれます。<br>
   Google App Engineがバックグラウンドで必要な設定を自動で行ってくれるので、ポート8080を手動で設定する必要がないわけです。</p>

  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(296).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p>Gunicorn（Green Unicorn）は、Pythonで書かれたWSGI（Web Server Gateway Interface）サーバーです。<br>
    簡単に言えば、Pythonのウェブアプリケーションを効率的に動かすためのサーバーです。</p>

   <dl>
    <dt>パフォーマンス</dt>
    <dd>軽量で、高性能なHTTPサーバーとして知られています。</dd>
    <dt>互換性</dt>
    <dd>多くのPythonフレームワーク（例：Django、Flaskなど）と互換性があります。</dd>
    <dt>簡単な設定</dt>
    <dd>設定が比較的簡単で、シンプルなコマンドで起動できます。</dd>
    <dt>スケーラビリティ</dt>
    <dd>複数のプロセスを使用してリクエストを処理するため、高トラフィックにも対応できます。</dd>
   </dl>
  </div>

  <p>例えば、FlaskアプリケーションをGunicornで起動する場合は、以下のようにコマンドを実行します。</p>

  <div class="code-container">
   <pre><code class="feintyping language-bash">
gunicorn myapp:app

</code></pre>
  </div>

  <p>ここで、myappはPythonファイルの名前、appはFlaskアプリケーションのインスタンス名です。</p>

  <p>このように既存の動作や設定を上書きして変更することをオーバーライド（override）と言うこともあります。<br>
   App Engineが通常自動的に行う設定を変更して、自分で特別なサーバーの起動方法を指定したい場合に、そのコマンドをentrypointで設定することで、App
   Engineが通常使う方法を「オーバーライド」することができるということです。</p>

  <h5>env_variables</h5>
  <p><span class="small-orange-text">※必ずしも設定する必要はありません。</span></p>
  <p>Google App Engine (GAE) では app.yaml でアプリの設定を行います。<br>
   このファイルの中で、環境変数を定義できます。<br>
   環境変数はプログラムにとって重要な情報を外部から渡すための仕組みです。<br>
   例えばある設定値をプログラム内で直接書くのではなく、外部からその値を与えることで、プログラムの再利用性が向上したり、設定の変更が容易になります。</p>

  <p>App Engineにおける環境変数は、以下のルールに従って定義されます。</p>

  <ul>
   <li>キー（変数名）はアルファベットまたはアンダースコア (_) で始まり、その後に英数字またはアンダースコアが続く必要があります。<br>
    例:MY_VARIABLE, ANOTHER_VAR123</li>
   <li>ただし、GAE で始まる名前は予約されており、使用できません。</li>
  </ul>

  <p>具体的には、次のように app.yaml ファイルに環境変数を定義します。</p>

  <div class="code-container">
   <pre><code class="feintyping language-yaml">
env_variables:
DJANGO_SETTINGS_MODULE: "myapp.settings"

</code></pre>
  </div>

  <p>Python では、定義した環境変数を os.environ という辞書を通じてアクセスできます。<br>
   例えば、上記の環境変数を読み取るには次のようにします。</p>

  <div class="code-container">
   <pre><code class="feintyping language-python">
import os

# 環境変数の値を取得
settings_module = os.environ.get('DJANGO_SETTINGS_MODULE')
print(settings_module) # "myapp.settings" と表示されるはずです。

</code></pre>
  </div>

  <p>このように環境変数を使うことで、アプリの設定や変更が柔軟に行えるようになります。<br>
   つまり、上記のようにapp.yamlファイルに環境変数を定義してからDjangoアプリをPythonで構成、Pythonスクリプト内で os モジュールを使用して環境変数を取得します。<br>
   それからApp Engineにアプリをデプロイすると、指定した環境変数の値が読み取られ、"myapp.settings" と表示されるのです。</p>

  <h5>error_handlers</h5>
  <p><span class="small-orange-text">※必ずしも設定する必要はありません。</span></p>
  <p>エラーハンドラはアプリでエラーが発生したときに表示されるカスタムエラーページを設定するためのものです。<br>
   ユーザーがエラーに遭遇したときに見やすくわかりやすいページを提供できます。<br>
   設定できる要素として、次のようなものがあります。</p>

  <dl>
   <dt>error_code</dt>
   <dd>エラーの種類を指定するためのオプションの要素です。次のいずれかを指定できます。</dd>
   <dd>over_quota: アプリがリソースの割り当てを超えたときに表示されます。</dd>
   <dd>timeout: アプリからレスポンスが返される前に時間切れになったときに表示されます。</dd>

   <dt>file</dt>
   <dd>エラーが発生したときに表示される静的ファイル（HTMLファイルなど）のパスを指定します。指定されたファイルが表示され、ユーザーに対してエラーメッセージを提供します。</dd>
  </dl>

  <p>app.yamlには次のように記述します。</p>
  <div class="code-container">
   <pre><code class="feintyping language-yaml">
error_handlers:
- file: default_error.html
- error_code: over_quota
file: over_quota.html

</code></pre>
  </div>

  <p>上記app.yamlだと、次のように動作します。<br>
   default_error.html ファイルは、全てのエラーに対するデフォルトのエラーページとして表示されます。<br>
   over_quota エラーの場合は、over_quota.html ファイルが表示されます。</p>

  <p>注意点として、カスタムエラーページのファイルパスが他の静的ファイルハンドラのパスと重ならないようにすること。<br>
   また、カスタムエラーページのデータサイズは10KB未満にする必要があります。<br>
   このように設定することで、ユーザーに対してより分かりやすいエラーメッセージを表示することができます。</p>

  <h5>handlers</h5>
  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(101).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p><span class="small-orange-text">※省略可能ではありますが、非常に重要な記述です。</span></p>
   <p>簡単に言うと、URLパターンと処理方法のリストです。<br>
    App Engineにおいて特定のURLにアクセスがあったときに、それをどのように処理するかを定義します。</p>

   <dl>
    <dt>動的コンテンツの処理</dt>
    <dd>ユーザーが特定のURLにアクセスしたとき、プログラムコードを実行して、そのリクエストに応じた内容を返します。<br>
     例えば、データベースからの情報を表示するなど。</dd>

    <dt>静的ファイルの提供</dt>
    <dd>画像や CSS、JavaScriptファイルなど、プログラムコードとは別にアップロードされた静的なファイルをユーザーに提供します。<br>
     これらのファイルは、通常、デザインやインタラクティブな要素を実現するために使われます。</dd>
   </dl>
  </div>

  <p>つまりhandlersは、どのURLにアクセスがあった場合にどのファイルやプログラムを使って応答するかを決める設定項目になります。<br>
   アプリケーションの動作や見た目を柔軟にコントロールするために必要な記述でしょう。</p>

  <h5>inbound_services</h5>
  <p><span class="small-orange-text">※必ずしも記述する必要はありません。</span></p>
  <p>Google App Engine上でアプリケーションが特定のリクエストを受け取れるようにするための設定です。<br>
   これらのサービスを有効にすることで、アプリケーションが適切に動作するようになります。<br>
   アプリケーションが受け取るインバウンドリクエストを指定します。─ 外部からのものという意味です。 ─</p>

  <p>warmup は特に「ウォームアップリクエスト」を有効にする設定です。<br>
   ウォームアップリクエストとは、App Engineが新しいインスタンス（アプリケーションのコピー）を起動する際に、そのインスタンスを事前に準備しておくためのリクエストです。<br>
   ユーザーがアクセスする前にインスタンスを温めておき、応答時間を短縮することができます。</p>

  <p>inbound_services セクションを使って warmup を有効にするためのコードを見てみましょう。</p>

  <div class="code-container">
   <pre><code class="feintyping language-yaml">
inbound_services:
- warmup

</code></pre>
  </div>

  <p>この設定を行うことで、新しいインスタンスが起動される際に自動的にウォームアップリクエストが送信され、アプリケーションがより迅速に応答できるようになります。</p>

  <h2>App Engineにおけるインスタンス</h2>
  <div class="flowerclearfix">
   <div class="flowerfade-out">
    <img src="/flower1/forest1(102).jpg" alt="フェードアウト効果の草花写真">
   </div>
   <p>App Engine でアプリケーションを実行するために「インスタンス」という単位が使われます。<br>
    インスタンスは、実際にアプリケーションコードを実行する環境のことです。<br>
    この言葉は非常に重要です。</p>

   <p>「inbound_servicesセクションを使ってwarmupを有効にする」説明文中にて、新しいインスタンス（アプリケーションのコピー）という表現を使っています。<br>
    この「コピー」という言葉が指しているのは、アプリケーションそのものではなく、アプリケーションの実行環境の複製です。<br>
    つまり、同じアプリケーションコードを実行する複数の環境（インスタンス）が存在するという意味です。</p>
  </div>


  <p>アプリケーションが人気で多くのユーザーがアクセスする場合、一つのインスタンスだけでは対応できません。<br>
   そのため、App Engine は必要に応じて新しいインスタンスを起動し、負荷を分散させます。<br>
   この仕組みがあることで、アクセスが増えてもアプリケーションが速く、安定して動作するようになります。</p>

  <p>Googleのものに限らず、クラウドに関連する用語は専門的に感じられることがあります。<br>
   ここで、デプロイとインスタンスについておさらいしてみましょう。</p>
  <dl>
   <dt>デプロイ</dt>
   <dd>ユーザーがアプリケーションを App Engine にアップロードすることを意味します。</dd>

   <dt>インスタンス</dt>
   <dd>デプロイされたアプリケーションを実行するための複数の環境です。<br>
    これが「コピー」と言われることもあります。</dd>
  </dl>

  <p>App Engineについて小話をしてみますね？<br>
   例えば、あなたが大人気のレストランを経営しているとしましょう。<br>
   一つのキッチン（インスタンス）だけでは全てのお客様に迅速に料理を提供するのが難しいため、複数のキッチン（インスタンス）を用意します。<br>
   それぞれのキッチンでは同じメニュー（アプリケーションコード）が作られますが、複数のキッチンがあることで多くのお客様に対応できるようになります。<br>
   こんな感じで、App Engine では負荷に応じて新しいインスタンス（キッチン）を起動し、アプリケーションがスムーズに動作するようにしているのです。</p>

  <h5>instance_class</h5>
  <p><span class="small-orange-text">※省略できますが、明示的に指定しておいたほうが良いでしょう。</span></p>
  <p>ここは「オンプレミスとクラウド」の違いがはっきりと分かる設定ですね。<br>
   オンプレミスは、データやシステムを自分の会社のサーバーに置くこと。<br>
   クラウドは、インターネットを通じて他の会社のサーバーにデータやシステムを置くこと。<br>
   自宅保管と貸し倉庫の違いに似ていますね。</p>

  <p>インスタンスクラスは、アプリケーションを動かすためのサーバーの性能や容量を決める設定です。<br>
   まるでコンピュータのスペックを選ぶようなものです。<br>
   サービスのスケーリングは、アプリケーションのアクセス量に応じてサーバーの数や性能を自動的に増減させる仕組みです。<br>
   では、これらの基礎を把握したうえで、App Engineでどのような設定ができるのか、見ていきます。</p>

  <h4>自動スケーリング</h4>
  <p>自動スケーリングはアクセスが増えたら自動でサーバーを増やし、減ったらサーバーを減らす仕組みです。<br>
   次のようなインスタンスクラスがあります。</p>
  <dl>
   <dt>F1</dt>
   <dd>基本的な性能。デフォルトの設定です。</dd>

   <dt>F2</dt>
   <dd>F1の2倍の性能。</dd>

   <dt>F4</dt>
   <dd>F1の4倍の性能。</dd>

   <dt>F4_1G</dt>
   <dd>F4と同じ性能ですが、メモリ容量が多い。</dd>
  </dl>

  <p>必要に応じて、automatic_scaling要素を使います。<br>
   インスタンスの数、レイテンシ（遅延）、同時接続の最小数と最大数などを調整することができます。</p>

  <p>把握しておいたほうが良い事柄として、インスタンスクラスをF2以上に設定している場合の設定があるでしょう。<br>
   max_concurrent_requests（同時接続数）をデフォルトの10より大きい値に設定するとインスタンスを最適化できます。<br>
   この最適な値を見つけるためには、少しずつ値を増やしてアプリケーションのパフォーマンスを監視する必要があります。</p>

  <h4>基本スケーリングと手動スケーリング</h4>
  <p>これらは一定の数のサーバーを使う方法です。</p>
  <dl>
   <dt>基本スケーリング</dt>
   <dd>一定の数のサーバーを使い、必要に応じて少し自動で調整します。</dd>

   <dt>手動スケーリング</dt>
   <dd>サーバーの数を固定して使います。</dd>
  </dl>

  <p>インスタンスクラスには次のような種類があります。</p>

  <dl>
   <dt>B1</dt>
   <dd>基本的な性能。</dd>

   <dt>B2</dt>
   <dd>B1の2倍の性能。デフォルト設定です。</dd>

   <dt>B4</dt>
   <dd>B1の4倍の性能。</dd>

   <dt>B4_1G</dt>
   <dd>B4と同じ性能ですが、メモリ容量が多い。</dd>

   <dt>B8</dt>
   <dd>B1の8倍の性能。</dd>
  </dl>

  <p>基本スケーリングや手動スケーリングを使う場合は、それぞれの要素（basic_scaling または manual_scaling）を指定する必要があります。</p>

  <p>App Engineに初めて設定する場合は、デフォルトのF1やB2を試してみて、必要に応じて変更するのが良いです。
   アクセスが変動する場合は自動スケーリング、一定の負荷がかかる場合は基本スケーリングや手動スケーリングを選びましょう。</p>

  <h4>F1とB1の違い</h4>
  <p>Fはフロントエンド、Bはバックエンドを意味します。</p>

  <p class="gra">F（フロントエンド）</p>
  <p>Fクラスのインスタンスは、短時間で素早くスケールアップやスケールダウンが必要なアプリケーション向けです。<br>
   例えばウェブサイトのフロントエンドや、ユーザーの操作に即座に応じる必要があるサービスに向いています。<br>
   基本的にアクセスが増減するタイミングが予測しにくい場合に適しています。</p>

  <p class="gra">B（バックエンド）</p>
  <p>Bクラスのインスタンスは、比較的長時間稼働し続けるアプリケーション向けです。<br>
   例えばデータベースのバックエンドや、一定の作業を継続的に行う必要があるサービスに向いています。<br>
   アクセスが安定している場合や、特定の時間に負荷が集中する場合に適しています。</p>

  <p>基礎的設定であるF1とB1について見てみましょう。</p>

  <dl>
   <dt>F1</dt>
   <dd>主に短時間のレスポンスを求められる用途向け</dd>
   <dd>自動スケーリングでアクセス量に応じて柔軟に対応</dd>

   <dt>B1</dt>
   <dd>一定時間以上の継続的な稼働を求められる用途向け</dd>
   <dd>手動スケーリングや基本スケーリングで安定した性能を提供</dd>
  </dl>

  <p>例えば、人気のイベントなどが開催されているときにアクセスが急増するウェブサイトの場合はF1が適しています。<br>
   一方、バックグラウンドでデータを処理し続けるアプリケーションの場合はB1が適しています。</p>

  <p>個人サイト領域であれば、静的なWebサイトという形でホスティングすることが多いでしょう。<br>
   特に初期のころはF1インスタンスクラスで十分なことが多いです。<br>
   自動スケーリングでF1を使用することで、アクセスが増えても柔軟に対応できます。<br>
   一方この設定を省略した場合、GoogleはデフォルトでF1を使用します。<br>
   つまり、特に指定しなくてもF1が使われるので、基本的には問題ないと言ってよいです。<br>
   必要があれば後でインスタンスクラスを変更することもできるので、まずはF1で試してみて、様子を見ながら調整するのが一般的です。</p>

  <h5>runtime</h5>
  <p><span class="small-orange-text">※これは必須の記述です</span></p>
  <p>ここいらへんで、おさらいの時間を作ります。<br>
   私がTwitterを見ている限り、コードを書いた上での個人サイトといえば「HTMLとレンタルサーバー」というキーワードが圧倒的大多数です。<br>
   例えばGCPなどクラウドを用いてホスティングしている人は、本当にごくわずかでした。─ 普段から開発系のSEアカウント等は除いて ─</p>

  <p>App Engine（アプリケーションエンジン）はGoogleが提供しているクラウドサービスの一つで、ウェブアプリケーションをホスティングするためのプラットフォームです。<br>
   app.yamlは、このApp Engineにデプロイするアプリケーションの設定ファイルです。<br>
   このファイルには、アプリケーションの動作環境や各種設定を記述します。</p>

  <p>まとめると次のようになります。</p>

  <dl>
   <dt>App Engine</dt>
   <dd>Googleのウェブアプリケーションホスティングサービス。</dd>

   <dt>app.yamlファイル</dt>
   <dd>アプリケーションの設定ファイル。</dd>

   <dt>ランタイム環境（runtime）</dt>
   <dd>アプリケーションを実行するためのプログラミング言語とそのバージョン。</dd>

   <dt>例（runtime: python312）</dt>
   <dd>Python 3.12の言語でアプリケーションを動かす設定。─ 他の言語でも良いです。後述します。 ─</dd>
  </dl>

  <p>「runtime」という項目は、「ランタイム環境」を指定するためのものです。<br>
   ランタイム環境とは、アプリケーションを実行するためのプログラミング言語やそのバージョンのことを指します。<br>
   たとえば、以下のように設定します。</p>

  <div class="code-container">
   <pre><code class="feintyping language-yaml">
runtime: python312

</code></pre>
  </div>

  <p>この例では、「python312」と指定しています。<br>
   これは、「Python 3.12」というバージョンのプログラミング言語を使用することを意味しています。<br>
   つまり、App Engine上でこのアプリケーションを実行する際に、Python 3.12が使われるということです。</p>

  <p>App Engineにはさまざまなランタイム環境があります。<br>
   よく聞く代表例は次のようなものがありますね。</p>

  <dl>
   <dt>Python</dt>
   <dd>python310、python311</dd>

   <dt>Java</dt>
   <dd>java8、java11</dd>

   <dt>Node.js</dt>
   <dd>nodejs16、nodejs18</dd>

   <dt>Go</dt>
   <dd>go116、go118</dd>

   <dt>PHP</dt>
   <dd>php74、php80</dd>

   <dt>Ruby</dt>
   <dd>ruby30、ruby31</dd>
  </dl>

  <p>これらのランタイム環境を使用して、対応するプログラミング言語とバージョンでアプリケーションを実行することができます。<br>
   設定ファイルに指定することで、App Engineが自動的に適切なランタイムを使用してアプリケーションをデプロイ・実行する仕組みです。</p>

  <h5>service</h5>
  <p><span class="small-orange-text">※サービスを作成する場合には必須です。default サービスでは省略できます。</span></p>
  <p>App Engineではウェブアプリケーションを「サービス」として管理します。<br>
   このサービスには名前を付ける必要があります。<br>
   サービスの設定は、アプリケーションの異なる部分を分けて管理するのに役立つでしょう。<br>
   とりあえず一つのサービスを「default」として設定できます。<br>
   この場合、特に名前を付ける必要はありません。<br>
   サービス名やバージョン名には次のようなルールがあります。</p>

  <dl>
   <dt>使える文字</dt>
   <dd>数字（0-9）、英字（a-z、A-Z）、ハイフン（-）</dd>

   <dt>長さの制限</dt>
   <dd>VERSION-dot-SERVICE-dot-PROJECT_ID という形式で、全体の長さが63文字以内にする必要があります。</dd>

   <dt>ハイフンの位置</dt>
   <dd>名前の先頭や末尾にハイフンは使えません。</dd>

   <dt>名前の一意性</dt>
   <dd>各サービスとバージョンには一意の名前を付ける必要があります。同じ名前を使ってはいけません。</dd>
  </dl>

  <p>app.yamlには次のように書きます。</p>
  <div class="code-container">
   <pre><code class="feintyping language-yaml">
service: service-name

</code></pre>
  </div>

  <p>この例では、サービス名として「service-name」を設定しています。<br>
   この名前が他のサービス名やバージョン名と重複しないようにする必要があります。</p>

  <h5>service_account</h5>
  <p><span class="small-orange-text">※必ずしも設定する必要はありません。</span></p>
  <p>特定のバージョンに関連付けられたサービスアカウントを指定するために使われます。<br>
   このサービスアカウントは、他のGoogle Cloudサービスにアクセスする際に使われます。<br>
   サービスアカウントを指定することで、アプリケーションが適切な権限でGoogle Cloudサービスにアクセスできるようになります。<br>
   この設定はオプションですが、セキュリティや権限管理の観点から非常に重要です。<br>
   例えば、データベースへのアクセスや、他のAPIを利用する際に必要な認証情報として機能します。<br>
   形式は次の通りです。</p>

  <span class="codecolor">[SERVICE_ACCOUNT_NAME]@[PROJECT_ID]<br>.iam.gserviceaccount.com</span>

  <ul>
   <li>SERVICE_ACCOUNT_NAME：サービスアカウントの名前</li>
   <li>PROJECT_ID：プロジェクトのID</li>
  </ul>

  <p>yamlには次のように指定します。</p>

  <div class="code-container">
   <pre><code class="feintyping language-yaml">
service_account: my-service-account@my-project-id.iam.gserviceaccount.com

</code></pre>
  </div>

  <p>この例では、「my-service-account」という名前のサービスアカウントを「my-project-id」というプロジェクトに関連付けています。</p>

  <h5>vpc_access_connector</h5>
  <span class="small-orange-text">※必ずしも設定する必要はありません。</span>
  <p>vpc_access_connector（PCアクセスコネクタ）は、アプリケーションが仮想プライベートクラウド（VPC）ネットワークの内部リソースにアクセスできるようにするための設定です。
   サーバーレス環境（例えばGoogle CloudのApp Engine）で、この設定を使ってネットワークリソースにリクエストを送信することができます。
   設定項目は次の通りです。</p>

  <p><strong>name</strong></p>
  <p>これは、サーバーレスVPCアクセスコネクタの完全修飾名です。<br>
   形式は <span class="codecolor">"projects/PROJECT_ID/locations/REGION/<br>
    connectors/CONNECTOR_NAME"</span> です。</p>

  <dl>
   <dt>PROJECT_ID</dt>
   <dd>プロジェクトのID</dd>

   <dt>REGION</dt>
   <dd>リージョン（地域）</dd>

   <dt>CONNECTOR_NAME</dt>
   <dd>コネクタの名前</dd>
  </dl>

  <p>yamlでは、次のように書きます。</p>

  <div class="code-container">
   <pre><code class="feintyping language-yaml">
vpc_access_connector:
  name: "projects/my-project/locations/us-central1/connectors/my-connector"

</code></pre>
  </div>

  <p><strong>egress_setting</strong></p>

  <p>これはオプションで省略可能なんですよね。<br>
   デフォルトは <span class="codecolor">private-ranges-only</span> です。<br>
   設定値は次の通りです。</p>

  <dl>
   <dt>private-ranges-only (デフォルト)</dt>
   <dd>内部IPアドレスへのリクエストはVPCネットワークに送信され、外部IPアドレスへのリクエストは公共のインターネットに送信されます。</dd>

   <dt>all-traffic</dt>
   <dd>すべてのリクエストがVPCネットワークに送信されます。</dd>
  </dl>

  <p>yamlには、次のように書きます。</p>
  <div class="code-container">
   <pre><code class="feintyping language-yaml">
vpc_access_connector:
  name: "projects/my-project/locations/us-central1/connectors/my-connector"
  egress_setting: all-traffic

</code></pre>
  </div>

  <p>要は vpc_access_connector の設定を使うことで、サーバーレスアプリケーションがVPCネットワークの内部リソースにアクセスできるようになるのです。<br>
   特に内部システムやデータベースにアクセスする場合に役立ちます。</p>

  <h3>ハンドラ要素</h3>
  <p>ここで、いったんまとめてみましょう。<br>
   Google App Engine の app.yaml ファイルは、アプリケーションの設定を管理する重要なファイルです。<br>
   このファイルには、アプリケーションがどのように動作するか、どのURLがどのように処理されるかなどが記載されています。</p>

  <dl>
   <dt>handlers 要素</dt>
   <dd>
    handlers 要素は、URLパターンとそれに対する処理方法のリストを提供します。<br>
    例えば、「/home」というURLが来たときに、それをどう処理するかを決めるのがこの要素です。
   </dd>

   <dt>アプリケーション コード</dt>
   <dd>
    アプリケーションのコードを実行したり、画像、CSS、JavaScriptなどの静的ファイルを提供する役割があります。
   </dd>

   <dt>パターンの評価</dt>
   <dd>
    app.yaml ファイルの記述は上から下へ順に評価されます。<br>
    例えば、最初に一致するURLパターンが見つかったら、それがリクエストの処理に使用されます。
   </dd>
  </dl>

  <p>改めてapp.yaml の具体例を見てみます。</p>

  <div class="code-container">
   <pre><code class="feintyping language-yaml">
handlers:
- url: /static
static_dir: static
- url: /.*
script: auto

</code></pre>
  </div>

  <p>この例では、2つのハンドラーが定義されています。</p>

  <dl>
   <dt>静的ファイル ハンドラー</dt>
   <dd>url: /static は、URLが "/static" で始まる場合に、static ディレクトリ内の静的ファイルを提供することを指定しています。</dd>
   <dt>スクリプト ハンドラー</dt>
   <dd>url: /.* は、上記以外のすべてのURLに対して、アプリケーションコードを実行することを指定しています。</dd>
   <dd>script: auto は、自動的にスクリプトを実行するよう指定しています。</dd>
  </dl>

  <p>では、各構文の説明へ戻ります。</p>

  <h5>auth_fail_action</h5>
  <p><span class="small-orange-text">※必ずしも記述する必要はありません。</span></p>
  <p>アプリケーションにログインが必要な場合に、ユーザーがログインしていない時にどのような動作をするかを指定する設定です。<br>
   この設定は次の2つの値のいずれかを持つことができます。</p>

  <dl>
   <dt>redirect（リダイレクト）:</dt>
   <dd>これはデフォルトの動作です。</dd>
   <dd>ユーザーがログインしていない場合、GoogleのログインページまたはOpenID認証を使用している場合は <span class="codecolor">/_ah/login_required</span>
    ページにリダイレクトされます。</dd>
   <dd>ログイン後、ユーザーは元のアプリケーションURLにリダイレクトされます。</dd>
   <dt>unauthorized（認証されていない）:</dt>
   <dd>ユーザーのリクエストを拒否し、HTTP 401ステータスコードとエラーメッセージを返します。</dd>
   <dd>これにより、ユーザーはログインページにリダイレクトされず、直接アクセスが拒否されます。</dd>
  </dl>

  <p>具体的に言うと、例えば auth_fail_action: unauthorized
   を設定した場合、ログインが必要なページにユーザーがログインしていない状態でアクセスすると、ログインページにリダイレクトする代わりに、アクセスが拒否されます（HTTP 401エラーが返されます）。<br>
   このように、auth_fail_action を使うことで、アプリケーションが特定のディレクトリ（例えば /profile/ ）にログインを要求するか、または（例えば /admin/
   ）に管理者のログインを要求するなどの動作をカスタマイズすることができます。</p>

  <h5>expiration</h5>
  <p><span class="small-orange-text">※必ずしも記述する必要はありません。</span></p>
  <p>静的ファイル（例えば画像、スタイルシート、JavaScriptファイルなど）をウェブプロキシやウェブブラウザでどれくらいの間キャッシュに保存するかを決める設定項目です。<br>
   キャッシュに保存すると、ユーザーが次回そのファイルをリクエストする際に、インターネットからではなく、ローカルのキャッシュから読み込むため、読み込み速度が速くなります。</p>

  <p class="gra">設定方法</p>
  <p>expirationの設定は、数値と単位をスペースで区切って指定します。<br>
   単位には次の4種類があります。</p>

  <ul>
   <li><strong>d</strong> : 日数</li>
   <li><strong>h</strong> : 時間</li>
   <li><strong>m</strong> : 分</li>
   <li><strong>s</strong> : 秒</li>
  </ul>

  <p>例えば、4d 5h と指定すると、キャッシュの有効期限はそのファイルが最初にリクエストされてから 4日と5時間後になります。</p>

  <p class="gra">コードの具体例</p>

  <ul>
   <li><span class="codecolor">1d</span> : 1日（24時間）</li>
   <li><span class="codecolor">12h</span> : 12時間</li>
   <li><span class="codecolor">30m</span> : 30分</li>
   <li><span class="codecolor">3600s</span> : 3600秒（1時間）</li>
  </ul>

  <p>もし expiration を省略した場合、アプリケーションの default_expiration（デフォルトの有効期限設定）が使用されます。<br>
   これで指定がない場合でも適切な有効期限が設定されるようになります。</p>

  <p>PWA（プログレッシブ・ウェブ・アプリ）の場合、サービスワーカーを使ってキャッシュを管理することが一般的です。<br>
   そのため、app.yamlファイルのexpiration設定を省略しても問題ありません。<br>
   サービスワーカーはキャッシュの制御を詳細に行えるため、アプリケーションのパフォーマンスを向上させることができます。</p>

  <h5>http_headers</h5>
  <p><span class="small-orange-text">※必ずしも記述する必要はありません。</span></p>
  <p>レスポンスにカスタムのHTTPヘッダーを追加するための設定です。<br>
   特定のヘッダー情報をクライアント（例えばブラウザ）に送ることができます。</p>

  <p>HTTPヘッダーは、クライアント（例えばブラウザ）とサーバー間の通信におけるメタデータのようなもので、通信の挙動や設定を制御する役割を持ちます。<br>
   次のような状況で役立ちますが、各々にちょっと説明が必要ですね。</p>

  <p class="gra">セキュリティ強化</p>
  <p>特定のHTTPヘッダーを追加することで、セキュリティを向上させることができます。<br>
   例えば、Content-Security-Policy (CSP) ヘッダーを追加することで、クロスサイトスクリプティング（XSS）攻撃や他の潜在的な脆弱性からの防御が強化されます。<br>
   CSP を YAML 設定ファイルに追加する方法として、次のようなコードが考えられます。</p>

  <div class="code-container">
   <pre><code class="feintyping language-yaml">
handlers:
- url: /images
static_dir: static/images
http_headers:
Content-Security-Policy: "default-src 'self'; img-src 'self' https://example.com; script-src 'self' 'unsafe-inline'"
X-Foo-Header: foo
X-Bar-Header: bar value
vary: Accept-Encoding
# ...

</code></pre>
  </div>

  <p>この設定では、次のポリシーを適用しています。</p>

  <dl>
   <dt>default-src 'self'</dt>
   <dd>デフォルトのすべてのコンテンツソースを自身のオリジンに限定します。</dd>

   <dt>img-src 'self' https://example.com</dt>
   <dd>画像のソースを自身のオリジンおよび https://example.com に限定します。</dd>

   <dt>script-src 'self' 'unsafe-inline'</dt>
   <dd>スクリプトのソースを自身のオリジンおよびインラインスクリプトに限定します。<br>
    注意: unsafe-inline の使用は避けるべきですが、特定の状況で必要な場合に使用されます</dd>
  </dl>

  <p>こうすることで、外部ソースからの不正なスクリプト実行やコンテンツの読み込みを防ぐことができます。<br>
   セキュリティポリシーは、必要に応じてさらにカスタマイズできます。<br>
   例えば、スタイルシートやフォントに関するポリシーを追加する場合、次のようなコードが考えられます。</p>

  <div class="code-container">
   <pre><code class="feintyping language-yaml">
http_headers:
Content-Security-Policy: "default-src 'self'; img-src 'self' https://example.com; script-src 'self' 'unsafe-inline';
style-src 'self' 'unsafe-inline'; font-src 'self'"

</code></pre>
  </div>

  <p>整理しましょう。<br>
   このコードは HTTP レスポンスヘッダーに Content-Security-Policy (CSP) を設定しています。<br>
   CSP ヘッダーは、ブラウザにどのリソースをどのソースから読み込むべきかを指示し、ウェブアプリケーションのセキュリティを強化します。<br>
   各ポリシーの意味を説明してみますね。</p>

  <dl>
   <dt>default-src 'self'</dt>
   <dd>デフォルトのソースポリシーを指定します。<br>
    上述のコードの場合、自身のオリジン（ドメイン）からのリソースのみを許可しています。<br>
    この指定により、他のソースからのコンテンツ読み込みがデフォルトで禁止されます。</dd>

   <dt>img-src 'self' https://example.com</dt>
   <dd>画像のソースポリシーを指定します。<br>
    上述のコードの場合、自身のオリジンおよび https://example.com からの画像のみを許可しています。<br>
    他のソースからの画像読み込みは許可されません。</dd>

   <dt>script-src 'self' 'unsafe-inline'</dt>
   <dd>スクリプトのソースポリシーを指定します。<br>
    上述のコードの場合、自身のオリジンおよびインラインスクリプトを許可しています。<br>
    ただし、unsafe-inline を許可することはセキュリティリスクがあるため、可能な限り避けるべきです。
   </dd>

   <dt>style-src 'self' 'unsafe-inline'</dt>
   <dd>スタイルシートのソースポリシーを指定します。<br>
    上述のコードの場合、自身のオリジンおよびインラインスタイルを許可しています。<br>
    インラインスタイルもまたセキュリティリスクがあるため、注意が必要です。</dd>

   <dt>font-src 'self'</dt>
   <dd>フォントのソースポリシーを指定します。<br>
    上述のコードの場合、自身のオリジンからのフォントのみを許可しています。<br>
    他のソースからのフォント読み込みは許可されません。</dd>
  </dl>

  <p>このように、各リソースに対して許可するソースを細かく設定することで、ウェブサイトが外部の不正なリソースを読み込むことを防ぎ、セキュリティを強化します。<br>
   必要に応じて、さらにポリシーをカスタマイズすることも可能です。<br>
   より包括的なセキュリティ強化が可能になりますね。</p>

  <p class="gra">コンテンツネゴシエーション</p>
  <p>Vary ヘッダーを使用して、クライアントがどのようなコンテンツを受け入れられるかを指定することができます。<br>
   コンテンツネゴシエーションとは、サーバーが異なるクライアントの要求に応じて最適なコンテンツを提供する仕組みです。<br>
   クライアントがどのコンテンツを受け入れられるかを指定し、サーバーが適切なバージョンのコンテンツを返すことができます。</p>

  <p>Vary ヘッダーは、レスポンスがどのリクエストヘッダーに基づいて異なるかをサーバーがクライアントに伝えるために使用されます。<br>
   たとえば、ブラウザが画像をリクエストする場合、異なる解像度やフォーマット（WebP, PNGなど）に応じて最適な画像を返すことができます。</p>

  <p>Vary ヘッダーを YAML 設定ファイルに追加する方法を書いてみます。</p>

  <div class="code-container">
   <pre><code class="feintyping language-yaml">
handlers:
- url: /images
static_dir: static/images
http_headers:
Vary: Accept, Accept-Encoding
X-Foo-Header: foo
X-Bar-Header: bar value
Content-Security-Policy: "default-src 'self'; img-src 'self' https://example.com; script-src 'self' 'unsafe-inline'"
# ...

</code></pre>
  </div>

  <p>この設定では、次の Vary ヘッダーがレスポンスに追加されます。</p>

  <dl>
   <dt>Accept</dt>
   <dd>クライアントがどのMIMEタイプを受け入れられるかを指定します。</dd>

   <dt>Accept-Encoding</dt>
   <dd>クライアントがどの圧縮エンコーディングを受け入れられるかを指定します。</dd>
  </dl>

  <p>これでサーバーはクライアントの要求に応じて最適なコンテンツを提供し、効率的な通信が可能になります。<br>
   ここでのポイントは、Vary ヘッダーにリクエストヘッダー（例: Accept や Accept-Encoding）を指定することで、サーバーがそのリクエストヘッダーを考慮してレスポンスを生成することを示していることです。</p>

  <p>例えば、クライアントが次のようなリクエストを送信した場合はどうなるでしょう。</p>

  <div class="code-container">
   <pre><code class="feintyping language-text">
GET /images/sample.png HTTP/1.1
Host: example.com
Accept: image/webp,image/apng,image/*,*/*
Accept-Encoding: gzip, deflate, br

</code></pre>
  </div>

  <p>サーバーはリクエストの Accept ヘッダーを基に、クライアントが受け入れ可能な画像形式（例: WebP 形式）を選び、Accept-Encoding ヘッダーを基に適切な圧縮形式（例: gzip 圧縮）を選びます。</p>

  <p>Vary ヘッダーは、そのリクエストヘッダーに基づいてレスポンスを変える必要があることを示しているので、実際のレスポンス生成においてどのリソースを返すかはサーバー側のロジックによるものです。<br>
   そのため、Vary ヘッダー自体には具体的な MIME タイプやエンコーディング形式を書かなくても良いのです。</p>

  <p>具体的な例として、以下のようにサーバーがリクエストに応じて異なるレスポンスを返すシナリオを考えてみます。</p>

  <ol>
   <li>クライアントが Accept: image/webp を送信した場合<br>
    サーバーは WebP 形式の画像を gzip 圧縮して返します。</li>
   <li>クライアントが Accept: image/png を送信した場合<br>
    サーバーは PNG 形式の画像を gzip 圧縮して返します。</li>
  </ol>

  <p>このように、Vary ヘッダーはサーバーがどのリクエストヘッダーに基づいて異なるレスポンスを生成するかを指定するためのものです。<br>
   ここではapp engineのyamlに限定して書いているため、少々分かりにくいかもしれません。<br>
   mdn web docsの「開発者向けのウェブ技術 > HTTP > <a
    href="https://developer.mozilla.org/ja/docs/Web/HTTP/Content_negotiation">コンテンツネゴシエーション</a>」に詳しい資料があります。</p>

  <p class="gra">キャッシュ制御</p>
  <p>Cache-Control ヘッダーを追加することで、ブラウザや他のクライアントがリソースをどのようにキャッシュするかを制御し、リソースの効率的な管理とパフォーマンスの最適化が可能になります。<br>
   YAML 設定ファイルに Cache-Control ヘッダーを追加する方法の例を見てみます。</p>

  <div class="code-container">
   <pre><code class="feintyping language-yaml">
handlers:
- url: /images
static_dir: static/images
http_headers:
Cache-Control: public, max-age=3600
Vary: Accept, Accept-Encoding
Content-Security-Policy: "default-src 'self'; img-src 'self' https://example.com; script-src 'self' 'unsafe-inline'"
# ...

</code></pre>
  </div>

  <p>この設定では、次の Cache-Control ヘッダーがレスポンスに追加されます。</p>

  <dl>
   <dt>public</dt>
   <dd>リソースがパブリックキャッシュ（例：CDN）にキャッシュされることを許可します。</dd>
   <dt>max-age=3600</dt>
   <dd>リソースがキャッシュされる最大時間（秒単位）を指定します。この例では、1時間（3600秒）です。</dd>
  </dl>

  <p>この設定により、クライアントはリソースを1時間キャッシュし、その間同じリソースを再リクエストする際にはキャッシュされたコピーを使用します。<br>
   これでサーバーの負荷が軽減され、ユーザーエクスペリエンスが向上します。</p>

  <p>キャッシュ制御の設定は、必要に応じてさらにカスタマイズできます。<br>
   変更されたリソースをすぐに反映させるために no-cache を使用する場合、次のようなコードが考えられます。</p>

  <div class="code-container">
   <pre><code class="feintyping language-yaml">
http_headers:
Cache-Control: no-cache

</code></pre>
  </div>

  <p>これでクライアントは毎回サーバーに対して新鮮なコピーをリクエストし、キャッシュを使用しません。</p>
  <p>次の設定は/images URLに対応する静的ファイルディレクトリにアクセスする場合に、いくつかのカスタムHTTPヘッダーを追加するものです。</p>

  <div class="code-container">
   <pre><code class="feintyping language-yaml">
handlers:
- url: /images
static_dir: static/images
http_headers:
X-Foo-Header: foo
X-Bar-Header: bar value
vary: Accept-Encoding
# ...

</code></pre>
  </div>

  <p>この例では、以下のHTTPヘッダーがレスポンスに追加されます。</p>

  <ul>
   <li>X-Foo-Header に foo</li>
   <li>X-Bar-Header に bar value</li>
   <li>vary に Accept-Encoding</li>
  </ul>

  <p class="gra">CORS サポート</p>
  <p>CORS（クロスオリジン リソース シェアリング）は、異なるドメインからのリソースアクセスを許可する仕組みです。<br>
   この機能が特に役立つのは、たとえば、あるアプリケーションが自分のドメインとは異なるドメインにあるリソースにアクセスしたい場合です。<br>
   ゲームアプリとアセットの例で詳しく説明しましょう。</p>

  <p>たとえば、ゲームアプリ（mygame.uc.r.appspot.com）があります。<br>
   このアプリは自分のドメインにホストされているリソース（画像、音声ファイルなど）だけでなく、別のドメイン（myassets.uc.r.appspot.com）にホストされているアセット（リソース）にもアクセスしたい場合があります。<br>
   ここでは、Google App Engineを使って、/images URLパスにリクエストがあった場合に静的ファイルを返す静的ファイルハンドラを設定し、その際にCORSのレスポンスヘッダーを返す方法について説明します。</p>

  <div class="code-container">
   <pre><code class="feintyping language-yaml">
handlers:
- url: /images
static_dir: static/images
http_headers:
Access-Control-Allow-Origin: https://mygame.uc.r.appspot.com
# ...

</code></pre>
  </div>

  <p>この設定では、次のことが行われます。</p>

  <ul>
   <li>/images パスに対するリクエストには、static/images ディレクトリ内の静的ファイルが返されます。</li>
   <li>http_headers セクションで指定されたHTTPヘッダーがレスポンスに追加されます。</li>
  </ul>

  <p>CORSのレスポンスヘッダーについては、次の説明となるでしょう。</p>

  <ul>
   <li>Access-Control-Allow-Origin: https://mygame.uc.r.appspot.com ヘッダーは、mygame.uc.r.appspot.com
    ドメインからのリソースアクセスを許可します。<br>
    これで、ゲームアプリがアセットをホストしている別のドメインからリソースにアクセスできるようになります。</li>
   <li>もし全てのドメインからのアクセスを許可したい場合は、ワイルドカード（*）を使用することができます。</li>
  </ul>

  <p>この設定の意味は、mygame.uc.r.appspot.com からのリクエストに対して static/images
   ディレクトリ内のリソースを返すとともに、CORSを利用して他のドメインからのリソースアクセスを許可するということです。<br>
   この設定方法が必要な理由は、セキュリティの観点から、通常ブラウザは異なるドメイン間でのリソース共有を制限しているためです。<br>
   CORSを設定することで、特定のドメインからのアクセスを許可することができます。</p>

  <!-- ●ここから人間用のフッター● -->
  <hr id="feinhr">
  <div class="spacer"></div>

  <section class="sitemap">
   <h2 class="sitemap_heading">サイトマップ</h2>
   <p><a href="/pages/pagelist">全ページをリスト化したサイトマップ</a>も用意していますが、けっこうなページ数があります。<br>
    下記の「カテゴリー分けサイトマップ」のほうが使いやすいでしょう。</p>
   <p><a href="/another-eden/anaden_sitemap.html">
     アナザーエデン関連ページ・サイトマップ</a><br>
    アナザーエデンの強敵戦やストーリーコンテンツのリスト、お勧めバッジなどを掲載したコーナーです。<br>
    期間限定のない普通のRPGですので、初心者でも安心して続けていけるゲームとなっています。<br>
    もっとも重要なグラスタについては、場所別に網羅した表があります。</p>


   <p><a href="/contents/site_create.html">
     個人サイトのホスティングとコンテンツ作成</a><br>
    個人でウェブサイトを作るなら時間をかけて。<br>
    HTML・CSS・JavaScriptの書き方はもちろん、無料かつ広告なしでホームページを作る方法を掲載したコーナーです。<br>
    Webデザインやレイアウトについても書いてあります。</p>
   <p><a href="/fish/fish_sitemap.html">魚釣りなどアウトドアのエリア</a><br>
    ゲームとパソコンだけじゃなく、アウトドアも趣味なんです。<br>
    このコーナーでは魚釣りの記録とか、魚料理のレシピ、はたまたサイクリングなどなど。<br>
    アウトドアに関連するコンテンツが詰め込まれています。</p>

  </section>

  <!-- ページ上部へ戻るボタン -->
  <button id="scrollToTopBtn" onclick="scrollToTop()">ページ上部へ戻る</button>
  <script src="/script/feinScroll.js"></script>

  <div class="spacer"></div>

  <footer>
   <!--common google digital leader-->

   <div id="commongdl"></div>
   <script src="/externalization/common.js"></script>

   <div class="spacer"></div>


   <div class="spacer"></div>
   <p class="portal" id="updated-date">この <a href="https://feinatelier.org/">fein's personal
     site</a> は、2023/7/4に開設された <a href="https://portal.feinatelier.org/">fein's portal</a>
    を母体として、yyyy/mm/ddに至るまで更新し続けられています。</p>
   <script>
    document.addEventListener('DOMContentLoaded', function () {
     const today = new Date();
     const year = today.getFullYear();
     const month = String(today.getMonth() + 1).padStart(2, '0');
     const day = String(today.getDate()).padStart(2, '0');
     const dateElement = document.getElementById('updated-date');
     dateElement.innerHTML = `この <a href="https://feinatelier.org/">Fein Atelier - org</a> は、2023/7/4に開設された <a href="https://portal.feinatelier.org/">fein's portal</a> を母体として、${year}/${month}/${day}に至るまで更新し続けられています。`;
    });
   </script>

  </footer>

 </div><!--レスポンシブデザイン-->

 <script src="/script/feinheadline1.js"></script><!--見出しの自動生成-->

 <!-- ●ここまで人間用のフッター。直下でbodyを閉める● -->
</body>

</html>
